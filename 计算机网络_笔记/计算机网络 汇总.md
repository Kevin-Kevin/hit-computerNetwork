# 计算机网络

> 本笔记基于 
>
> **计算机网络 第 7 版 谢希仁 编著**
>
> 部分参考了 计算机网络 自顶向下方法 第 7 版
>
> 



## 概述

### 分组交换

把较长的信息分成一个个等长的数据段, 加上首部后构成一个**分组**, 分组又称为包, 分组首部可称为**包头**

路由器则是用来转发分组的, 既分组交换

一个分组到了路由器, 路由器先存起来, 寻找合适的链路转发

> 交换方式有三种
>
> 电路交换, 报文交换, 分组交换
>
> 前两种不重要

### 计算机网络的不同类别

1. 广域网 WAN(Wide Area Network)
2. 城域网 MAN(Metropolitan Area Network)
3. 局域网 LAN(Local Area Network)
4. 个人区域网 PAN(Personal Area Network)

> 具体概念见 计算机网络 谢希仁 Page 20

### 计算机网络性能指标

1. 速率
2. 带宽 (和模电的概念不一样)
3. 吞吐量
4. **时延**
5. 时延带宽积
6. **往返时间 RTT**
7. 利用率

### 具有五层协议的计算机网络体系结构 

> 具体概念见 Page 31

![Screen Shot 2021-03-11 at 12.48.21](https://gitee.com/kevinzhang1999/my-picture/raw/master/uPic/Screen%20Shot%202021-03-11%20at%2012.48.21-1615438125890.png)

## 物理层

### 信道复用技术

一条路给多个人使用

1. 频分复用

2. 时分复用

3. 统计时分复用

4. 波分复用
5. 码分复用(光的频分复用)

## 数据链路层

> 1. 以太网帧格式
>
> 2. MTU
>
> 3. ARP 协议, 报文格式, 查询原理, 缓存
>



### 链路, 数据链路, 帧

> Page 71

### 三个基本问题

- 封装成帧

  ip 数据报加上首部和尾部, 构成一个帧

  其实是加上了一个边界, 告诉你我这一帧的开始和结尾

  首尾部还有一些控制信息, 比如帧的数据部分长度上限---最大传输单元 MTU

- 透明传输
  解决帧的数据部分如果出现了和尾部一样的部分会被错认为是一个帧的问题

- 差错检测

  使用 循环冗余检验 CRC  ( Cyclic Redundancy Check ) 

  解决了比特在传输过程中有可能会从 0-1或者 1-0



#### 局域网 ( 也可以说是以太网 ) 

多台主机的网络适配器( 网卡 )通过交换机连接成局域网

#### 以太网帧

![Screen Shot 2021-03-11 at 16.34.17](https://gitee.com/kevinzhang1999/my-picture/raw/master/uPic/Screen%20Shot%202021-03-11%20at%2016.34.17-1615451673570.png)

1. 以太网帧 **数据** 字段为 46-1500 字节, **IP 数据报小于 46 字节会被填充**
2. 目的地址和源地址字段都是其 Mac 地址
3. 类型字段代表后面数据使用的协议, 如 IP 协议, ARP ...
4. 以太网帧没有尾部, 因为曼彻斯特编码, 只要在结束后不发送, 就代表帧结束
5. 图中 FCS 为帧检验序列, 使用 CRC 进行差错检测



### 网络适配器 ( 网卡 )

也有 cpu, ram, rom

具有过滤功能可以识别帧目的 Mac 地址是否是本机 Mac 地址

### Mac 地址

每个网络适配器都有一个唯一的 Mac 地址

在以太网 Mac 帧的首部包含目的 Mac 地址和源 Mac 地址

Mac 地址存储在其网卡的 rom 中

### 地址解析协议 ARP ( Address Resolution Protocol)

根据 IP 地址解析出 Mac 地址

每台主机或者路由器内存中都有一个 ARP 表 ( ARP cache )

该表存储了局域网内各主机的和路由器的 IP 地址和 Mac 地址

当主机要向局域网内主机发送 IP 数据报时, 先看 ARP cache 中有没有

> 如果没有
>
> ARP 进程会在本局域网上广播发送一个 ARP 请求分组	
>
> 分组中包含本机 IP 地址, Mac 地址以及要访问的 IP 地址
>
> 所有主机都会接收到, 但是只有要访问的 IP 地址的主机会响应一个单播



### 交换机

交换机中有一个交换机表

 其中包含了 Mac 地址, 对应的端口号, 以及老化期时间

每次收到一个以太网帧, 交换机会解析以太网帧, 获取 Mac 地址

然后将此 Mac 地址和接收此帧的端口号放入表中 



### ppp, 广播信道, 碰撞检测用不到, 就不写了

##  网络层

> 1. ip 数据报首部格式
> 2. ip 分片
> 3. ip 选路
> 4. 协议 : ICMP, IP



### IP 地址

#### IPv4 编址

每个 IP 地址长度为 32 比特, 既 4 个字节, 按点分十进制来书写,如 :  `192.168.0.1`

#### IP 地址分类

IP 地址被分为若干个固定的类, 由两个固定长度的字段组成 : 

**网络号 net-id 和 主机号 host-id**

> CIDR 的出现消除了下图的分类, 使得网络号是不固定的, 减少了路由器中路由表的规模, 后面会写到 CIDR

![image-20210312150536129](../../../Library/Application%20Support/typora-user-images/image-20210312150536129.png)

有几个特殊的 ip 地址

![image-20210312151356686](https://gitee.com/kevinzhang1999/my-picture/raw/master/uPic/image-20210312151356686-1615533236804.png)

路由器转发时根据网络号转发, 网络号一样的就属于一片区域

区域内是由用转发器或网桥连接起来的若干个局域网, 这片区域内的主机的网络号必须一致

路由器由于在两个区域的交界处就要有两个 IP 地址 , 这种主机称为多归属主机





### IP 数据报的格式

![image-20210311173837321](https://gitee.com/kevinzhang1999/my-picture/raw/master/uPic/image-20210311173837321-1615455517495.png)

各字段含义 :  

> 先讲一下分片
>
> 数据链路层协议规定了一个帧中数据字段的最大长度, 既最大传输单元 MTU ( max transfer unit )
>
> 数据报长了就要分片



1. 版本字段 : IP 协议的版本, 目前广泛使用 IPv4, 既 IP version 4

2. 首部长度 字段 :  占 4 位, 令其值为 n , 则首部长度 = n×32 (位) = n×4 (字节)

3. 区分服务 :   一般不用

4. 总长度 :  首部和数据部分之和, 单位是字节

5. 标识 : 每产生一个数据报, 计数器就加 1, 这样可以因为 MTU 分片时正确把拆分的片合起来

6. 标志 :   占 3 位, 只有后两位有意义
   - MF (more fragment) : 为 1 代表后面还有分片, 为 0 代表这是数据报分片中的最后一片
   - DF (don't fragment) : 为 1 代表不能分片, 为 0 才可以分片

7. 片偏移 :  占 13 位, 单位是 8 个字节. 代表原先此片在未分片前原分组中的起始位置, 这也说明了分片的长度一定是 8字节 的倍数

   ![image-20210311221910533](https://gitee.com/kevinzhang1999/my-picture/raw/master/uPic/image-20210311221910533-1615472350701.png)

8. 生存时间 : 8 位, TTL time to live , 数据报每经过一个路由器, 减去一段时间, 为 0 就丢弃数据报; 现在变为**跳数**, 经过一个路由器就减 1

9. 协议 :  代表数据部分使用的协议,  tcp, udp, ICMP 

10. 首部校验和 :  只校验首部, 采用反码算数运算求和

11. 源地址 :  本机 IP 地址

12. 目的地址 :  目的 IP 地址

13. 首部可变部分 : 若此部分不是 32bit 的倍数, 则在后面补 0, 直到是 32bit 的倍数



#### IP 层转发分组的流程

路由器将局域网连接起来, 路由器 R1 可以看成既在网 1 中,又在网 2 中

路由器将收到的分组的目的 IP 地址 D 和子网掩码进行与运算, 得出目的主机的所在的网络 N

然后查询路由表, 得到下一跳的地址, 然后将分组转发给下一跳

下一跳的路由器继续上诉操作, 直到发送的指定的网络 N 中

> 路由表中不只有下图的两种信息, 还有其余信息
>
> 表中的下一跳地址是 IP 地址, 但是IP 数据报首部中没有"下一跳的 IP 地址", 实际上是转换成目的 Mac 地址 ( 使用 ARP ) 放到以太网帧的首部
>
> 分组在进行转发的时候实际上是到一个地方问下一个地方怎么走, 而不是一开始就有具体的路线

![image-20210312180724273](https://gitee.com/kevinzhang1999/my-picture/raw/master/uPic/image-20210312180724273-1615543644441.png)

![image-20210312183953759](https://gitee.com/kevinzhang1999/my-picture/raw/master/uPic/image-20210312183953759-1615545593880.png)

### 划分子网和构造超网

####   CIDR 无分类编址

IP 地址被划分成 网络前缀 和 主机号

CIDR 使用地址掩码, 也可称为子网掩码

相同网络前缀的IP 地址为一个CIDR 地址块

#### 最长前缀匹配

由于 CIDR 被采用, 路由表主要信息就改成了 " 网络前缀 " 和 " 下一跳的地址 "

目的IP 地址算出目的网络地址后, 如果和多个前缀都匹配, 选择最长的前缀

查找匹配时采用线索二叉树

###  网际控制报文协议 ICMP ( Internet Control Message protocol )

ICMP 报文作为 IP 数据报的数据字段被发送

![image-20210312185537588](https://gitee.com/kevinzhang1999/my-picture/raw/master/uPic/image-20210312185537588-1615546537764.png)

#### ICMP 报文种类

- ICMP 差错报告报文 ( 该种类又有 4 种类型 )

  - 终点不可达
  - 时间超过
  - 参数问题
  - 改变路由 ( 重定向 )  

  下图是 ICMP 报文的结构 :  

  ICMP 将出错的 IP 数据报的首部和其数据字段的前 8 个字节作为 ICMP 的数据字段

  > 出错的 IP 数据报的数据字段前 8 个字节中有运输层的端口号和运输层报文的发送序号
  >

  再加上 ICMP 的首部 8 个字节

  ![image-20210312201557222](https://gitee.com/kevinzhang1999/my-picture/raw/master/uPic/image-20210312201557222-1615551357389.png)

- ICMP 询问报文 ( 分为两种 )
  
  - 回送请求和回答
  - 时间戳请求和回答
  
  ![image-20210312202243846](https://gitee.com/kevinzhang1999/my-picture/raw/master/uPic/image-20210312202243846-1615551763971.png)
  
  > ping 命令直接使用 ICMP 未经过运输层



### 互联网路由选择协议

既路由是怎么获取到路由表的

未完待续 ...

### 这之后还有知识点, vpn 和 nat ... ,现在对我没用, 不整理



## 运输层

### 概述

#### 运输层协议

有两个协议

- 用户数据报协议 UDP(User Datagram Protocol)

- 传输控制协议 TCP(Transmission Control Protocol)

运送协议数据单元称为 TCP 报文段 (segment) 和 UDP 用户数据报

#### 端口port

ip 地址加端口号对用一台主机上的一个进程

- 服务器端口使用的端口号
  1.系统端口号 aka 熟知端口号(wellknown port number) : 0-1023

  ![image-20210321170319526](https://gitee.com/kevinzhang1999/my-picture/raw/master/uPic/image-20210321170319526-1616317399725.png)

  2. 登记端口号 : 1024-49151, 在 IANA 登记过

- 客户端使用的端口号 : 49152-65535 ,aka 短暂端口号, 由系统分配, 通信结束后就不存在

### 用户数据报协议 udp

#### 概述

在 ip 的数据报服务上增加了复用和分用以及差错检测

##### 主要特点 

1. 无连接, 发送数据不需要建立连接
2. 尽最大努力交付, 不保证可靠交付
3. 面向报文, 保留应用层报文边界, 不合并也不拆分
4. 没有拥塞控制, 就算网络拥塞, 源主机还是以同样的速率发送
5. 支持一对一或多, 多对一或多的通信
6. 首部开销少, 只有 8 个字节 

##### udp 的首部格式

首部有四个字段

1. 源端口 : 不需要对方回信时可用全 0
2. 目的端口
3. 长度 : udp 用户数据报的长度, 最小为 8 字节, 只有首部
4. 检验和 : 检验 udp 报文是否出错

##### udp 的接收

运输层从 ip 层收到 udp 数据报时, 接收方 udp 如果发现不存在对应端口号的应用进程, 会丢弃报文并发送 icmp "端口不可达" 差错报文

校验和的计算也比较特殊, 在 udp 报文前添加12

个字节的伪首部, 然后计算

> 具体计算过程见 Page 210

![image-20210321173244303](https://gitee.com/kevinzhang1999/my-picture/raw/master/uPic/image-20210321173244303-1616319164436.png)

### 传输控制协议 tcp 概述

#### 特点

1. 面向连接, 使用前必须建立 tcp 连接
2. 每一条 tcp 连接是点对点的, 只能有两个端点 endpoint
3. 提供可高交付, 通过 tcp 连接传送的数据, 无差错, 不丢失, 不重复, 按序到达
4. 全双工通信, 通信双方任何时候都能发送数据, 因为两端都有发送和接收缓存
5. 面向字节流, 只认识字节



#### tcp 的连接

每条 tcp 的连接有两个端点, 叫做套接字 socket 或插口

![image-20210321173950845](https://gitee.com/kevinzhang1999/my-picture/raw/master/uPic/image-20210321173950845-1616319590971.png)

⭐️ 注意 : socket 有多种意思

![image-20210321174251544](https://gitee.com/kevinzhang1999/my-picture/raw/master/uPic/image-20210321174251544-1616319771665.png)

#### tcp 的首部格式

![image-20210321210515908](https://gitee.com/kevinzhang1999/my-picture/raw/master/uPic/image-20210321210515908-1616331916084.png)

首部各字段意义 : 

1. 源端口 和 目的端口 : 各占 2 个字节, 填入源端口号和目的端口号

2. 序号  : 4 个字节, 范围 [0, 2^32-1] , 共 2^32 个, 序号增加到 2^32-1 后回到 0 ; tcp 是面向字节流的 , 在一个 tcp 连接中每一个字节都按顺序编号, **序号**字段存储的是本次报文段数据部分第一个字节的序号

   ![image-20210321231935591](https://gitee.com/kevinzhang1999/my-picture/raw/master/uPic/image-20210321231935591-1616339975753.png)

3. 确认号 : 4 个字节

### 可靠传输的工作原理

ip 层只能提供尽最大努力服务, 是不可靠传输, 这时就要靠 tcp 使得传输可靠



#### 停等ARQ协议

发送完一个分组就停止发送, 等待对方确认, 收到确认后再发送下一个分组

##### 出现差错

发送方一段时间内没有收到确认, 就重传前面的分组, 称作超时重传, 每次发送玩一个分组就设置一个超时计时器

差错有以下几种情况

1. 发送的分组丢失

   重传就好, 但是有 3 点

   1. 发送方必须保留已发送的分组副本
   2. 分组和确认分组进行编号, 停等协议只要用一位编号就好, 但是对于其他的传输层协议就要复杂些
   3. 超时计时器的重传时间要比数据在分组传输的平均往返时间更长一些

2. 接收方发送的确认分组丢失

   发送方只要重传就好, 问题在于接收方, 这是第二次接收到同一个分组, 应采取两个行动

   1. 丢弃这个重复分组
   2. 再次发送确认分组 

3. 确认分组迟到

   > 第一次发送后接收方本应该发送确认分组, 但是该分组迟到了, 导致发送方重传, 此时接收方收到后再次发送确认分组, 发送方就会收到两次确认分组

   发送方收到重复的确认分组就丢弃

自动重传机制称为**自动重传请求协议** automatic repeat reQuest, ARQ

#### 连续 ARQ 协议

停等协议每次只发送一个分组, 而连续 arq 协议每次维持一个窗口, 每次都把





#### 

#### 

#### 

#### 

#### 

#### 

#### 

#### 

#### 

#### 

#### 

#### 

#### 

#### 

#### 

#### 

#### 

#### 



































## 总结

### 数据发送封装过程

![image-20210308144417311](https://gitee.com/kevinzhang1999/my-picture/raw/master/uPic/image-20210308144417311-1615185857534.png)

### 数据接收拆分过程

![image-20210308144953162](https://gitee.com/kevinzhang1999/my-picture/raw/master/uPic/image-20210308144953162-1615186193341.png)

